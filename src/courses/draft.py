"""
Content Management System (CMS) - система управления содержимым

---------------------------------------------------------------------------------------------
                        Фикстуры

https://software-testing.ru/library/testing/testing-automation/3357-pytest-the-awesome-parts-fixtures
https://qna.habr.com/q/70560

Фикстуры - это по сути тестовые данные. Они нужны для unit-тестирования.
Это могут быть как данные в базе, так и обычные файлы (обычно 2 варианта, до и после обработки так скажем).
Каждый раз когда запускаются тесты, эти данные используются для установления начального состояния системы,
что бы тесты всегда выполнялись предсказуемо.

Для функционального тестирования (тестрирование контроллеров, интаграционных тестов) фикстуры не применяются,
хотя суть там так же сходна. Если честно, то тут мнение расходится. Одни говорят что при функциональных тестах
нельзя использовать даже моки, то есть система в процессе выполнения тестов полностью создает то состояние
которое необходимо для других тестов. Например последовательное выполнение тестов на добавление статьи и
ее просмотр. Другие же предпочитают для каждого тесткейса выставлять состояние с нуля.
По сути это схоже с использованием фикстур, но реализация различается.
У вас есть некое api для заполнения данными (скажем метод добавляющий пользователя),
и перед выполнением тест-кейса происходит ресет данных и заполнение их новыми.
Плюсы так же есть - можно распаралелить выполнение тестов. (но не верьте мне на слово)

Миграции - механизм организации версионности структуры проекта.
Вы можете написать миграцию для изменения местоположения статики
(картинки, поменять ссылки в базе и т.д.), или же у вас добавляется новая таблица/поле.
Обычно дополняется обратной миграцией, которая восстанавливает исходную структуру.
Обязательно для работы в команде или при частом изменении организации данных в проекте,
вообще я бы посоветовал использовать их всегда.

Django поддурживает форматы JSON, XML и даже YAML

Основные две команды, как загружать и выгружать данные из db

python manage.py dumpdata   - выгружает дынные из db
python manage.py loaddata   - загружает дынные в db

Пример использования:
python manage.py dumpdata courses --indent=2

Такая команда выгрузит данные из всех моделей, из приложения courses
в формате JSON (по умолчанию) с пробелом 2(--indent=2)
можно применить флаг --format чтобы задать формат вывода

как сохранить в какой-то файл?
python manage.py dumpdata courses --indent=2 --output=courses/fixtures/subjects.json

Как получить инфу о всех параметрах dumpdata?
python manage.py dumpdata --help

Команда для того, чтобы загрузить данные в db:
python manage.py loaddata subjects.json

Но, но, но...
Есть одна проблемка. Если данные на русском языке, то они выгрузятся с кодировкой UTF-8
и обратно не загрузятся. Такие дела.
Гуглил как решить эту issue, но так и не нашел, такое ощущение, что эта проблема только у меня.

По умолчанию django ищет фикстуры в папке fixtures/ каждого приложения, но можно указать полный
путь до них. Также есть возможность задать каталоги где искать фикстуры
с помощью константы FIXTURE_DIRS в settings.py

Фикстуры - отличный способ заполнить базу данных начальными объектами, также
очень удобно применять их при тестировании.

Про фикстуры и тестирование в doc:
https://docs.djangoproject.com/en/3.2/topics/testing/
https://docs.djangoproject.com/en/3.2/ref/django-admin/#django-admin-loaddata
https://docs.djangoproject.com/en/3.2/howto/initial-data/


Но если данные на английском языке, то все нормально выгружает и загружает:
$ python manage.py dumpdata courses --indent=2 --format=json --output=courses/fixtures/subjects.json

$ python manage.py loaddata subjects.json
Installed 5 object(s) from 1 fixture(s)


---------------------------------------------------------------------------------------------
                        Виды наследования моделей Django

3 вида наследования моделей:

1) абстрактные модели
2) наследование с помощью нескольких таблиц
3) прокси модели

------- Абстрактная модель
Абстрактная модель - это базовый класс. В нем необходимо определить поля, которые будут общими для
всех дочерних классов.
Абстрактные модели полезны, когда нужно описать некую общую базовую информацию.
(вспомни AbstractUser, AbstractBaseUser). Для абстрактоной модели не создается таблица в бд
а вот в модели, от которой она наследуется создается.

Как сделать абстрактную модель? присвоить атрибут abstract = True в классе Meta модели.

Пример абстрактной модели BaseContent и дочерней Text

class BaseContent(Model):
    title = CharField(max_length=250)
    created = DatetimeField(auto_now_add=True)

    class Meta:
        abstract = True

class Text(BaseContent):
    body = TextField()

В этом случае в бд будет создана только одна таблица - Text (<app_name>_text).


------- Наследование с несколькими таблицами
В случае наследования с несколькими таблицами, для каждой модели создается соответствующая таблица.
Для каждой из моделей создается своя собственная таблица
Django делает ссылку OneToOneField на родительскую модель из дочерней.
Чтобы применить этот метод нужно просто унаследовать дочерней модели от родительской.

class BaseContent(Model):
    title = CharField(max_length=250)
    created = DatetimeField(auto_now_add=True)

class Text(BaseContent):
    body = TextField()

Не совсем понятно для чего она и какие у нее преимущества.

------- Прокси-модели
Они используются когда модели хранят одинаковые данные но поведение классов отличается.
Полезно, когда мы хотим реализовать для каждой из моделей отдельную функциональность
(методы, переопределить или добавить менеджеры, использовать другие опции класса Meta)
Разумеется таблицы для proxy-моделей в бд не создаются.

как определить proxy модель? добавить атрибут proxy=True в класс Meta модели.

Пример proxy модели:

class BaseContent(Model):
    title = CharField(max_length=250)
    created = DatetimeField(auto_now_add=True)


class OrderingContent(BaseContent):

    class Meta:
        proxy = True
        ordering = [-'created',]

    def created_delta(self):
        return timezone.now() - self.created

В донном случае OrderingContent добавит сортировку по умолчанию для QuerySet и метод created_delta
"""

# То что мы сделали в модели Content - называется обощенная связь
# Возможность соединить модель Content с любой другой моделью представляющей тип содержимого
# (на самом деле вообще с любой моделью)

# Базовый синтаксис для обощенных связей таков, что нужно создать три поля в модели:
# 1) content_type - ForeignKey на модель ContentType
# 2) object_id - идентификатор связанного объекта (PositiveIntegerField
# 3) item - поле типа GenericForeignKey которое обощает данные из предыдущих двух.

# Только поля content_type и object_id будут иметь столбцы в бд
# поле item (GenericForeignKey) - используется только в python коде, хранится
# в оперативной памяти, позволяет нам получить или задать связанный объект.
